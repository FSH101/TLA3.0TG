name: Import files from another GitHub repo (copy, no history)

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: "owner/name исходного репозитория"
        required: true
        default: "SacredCracker/FOnline-TlaMk2"
      source_ref:
        description: "Ветка/тег/коммит исходника"
        required: true
        default: "2012-old-version"
      sparse_paths:
        description: "Строки для sparse-checkout (оставь пустым, чтобы взять всё)"
        required: false
        default: |
      dest_path:
        description: "Папка в ЭТОМ репо, куда сложить файлы"
        required: true
        default: "external/FOnline-TlaMk2"
      target_branch:
        description: "Ветка ЭТОГО репо для коммита (создадим если нет)"
        required: true
        default: "import-fonline"
      commit_message:
        description: "Текст коммита"
        required: true
        default: "Import from external repo"
      use_private_token:
        description: "Для приватного исходника используем secrets.SOURCE_REPO_TOKEN (true/false)"
        required: false
        default: "false"

jobs:
  import:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      # 0) Чекаутим ЭТО репо на ДЕФОЛТНУЮ ветку (НЕ target_branch!)
      - name: Checkout this repo (default branch, shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: false
          # ref НЕ указываем, тогда возьмётся default-ветка репо

      # 0.1) Создаём/переключаемся на target_branch от дефолтной
      - name: Create or switch to target branch
        shell: bash
        run: |
          set -e
          BR="${{ github.event.inputs.target_branch }}"
          # определяем дефолтную ветку origin (main/master)
          DEF=$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')
          if [ -z "$DEF" ]; then
            if git ls-remote --exit-code --heads origin main >/dev/null 2>&1; then DEF=main; else DEF=master; fi
          fi
          echo "Default branch detected: $DEF"
          git fetch --depth=1 origin "$DEF"
          if git ls-remote --exit-code --heads origin "$BR" >/dev/null 2>&1; then
            # ветка уже существует на origin — переключаемся на неё
            git fetch --depth=1 origin "$BR"
            git checkout -B "$BR" "origin/$BR"
          else
            # ветки ещё нет — создаём от дефолтной
            git checkout -B "$BR" "origin/$DEF"
          fi

      # 1) Чекаут исходного репо в _src (шаллоу + опционально sparse)
      - name: Checkout source repo (sparse if paths provided)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.source_repo }}
          ref: ${{ github.event.inputs.source_ref }}
          path: _src
          fetch-depth: 1
          fetch-tags: false
          token: ${{ github.event.inputs.use_private_token == 'true' && secrets.SOURCE_REPO_TOKEN || '' }}
          sparse-checkout: ${{ github.event.inputs.sparse_paths }}
          sparse-checkout-cone: false

      # 2) Копируем файлы
      - name: Copy files into destination
        shell: bash
        run: |
          set -e
          DEST="${{ github.event.inputs.dest_path }}"
          mkdir -p "$DEST"
          rsync -a --delete --exclude ".git/" "_src/" "$DEST/"

          echo "Imported into: $DEST"
          # Без пайпов, чтобы не ловить Broken pipe
          find "$DEST" -mindepth 1 -maxdepth 5 -print > .import_list.txt || true
          head -n 100 .import_list.txt || true

      # 3) Коммит и пуш
      - name: Commit & push
        shell: bash
        run: |
          set -e
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add -A
          git commit -m "${{ github.event.inputs.commit_message }}" || echo "No changes"
          git push --set-upstream origin "${{ github.event.inputs.target_branch }}"
