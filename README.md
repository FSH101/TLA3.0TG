# TLA Online MVP

Этот репозиторий содержит монорепозиторий MVP для веб-порта TLA: сервер авторитета, канвас-клиент и общие типы сообщений.

## Структура

```
.
├── client/   # Vite + TypeScript фронт, канвас-рендер и сетевой стек
├── server/   # Node.js/Express + ws сервер авторитета мира
├── shared/   # Общие контрактные типы сообщений и состояния
├── assets_1/ # Сырые исходники Fallout-ассетов (см. раздел про пайплайн ассетов)
├── external/ # Источники для бэкенда/клиента FOnline (для справки)
└── falloutweb/ # Пример оффлайн-порта (источник идей)
```

## Локальный запуск

1. Установите зависимости один раз:
   ```bash
   npm install
   ```
2. Соберите всё приложение:
   ```bash
   npm run build
   ```
3. Запустите сервер (по умолчанию порт `3000`):
   ```bash
   npm run dev
   ```
4. Откройте `http://localhost:3000` в нескольких вкладках браузера, чтобы проверить мультиплеер.

Сервер слушает `process.env.PORT` и при старте пишет в логи `listening on PORT …`. HTTP и WebSocket (путь `/ws`) работают на одном хосте и порту.

## Ассеты и манифест

- Клиент сначала запрашивает манифест `client/public/assets/asset-manifest.json` (можно вынести на CDN), затем подгружает тайлы/спрайты.
- Локальный репозиторий не содержит бинарных ассетов. В продакшене используйте пайплайн преобразования исходников Fallout из `assets_1/art` → WebP/PNG → выгрузка в объектное хранилище (Cloudflare R2/S3/B2) → обновление манифеста CDN-URL-ами с хешами.
- Если ассет недоступен (404/ошибка сети), клиент рисует заглушку (однотонная плитка/прямоугольник) и продолжает работу.

### Минимальный набор ассетов (хранятся на CDN)

| Логическое имя | Назначение | Примерный CDN-URL |
| -------------- | ---------- | ----------------- |
| floor          | Тайлы пола | `https://cdn.example.com/tiles/floor_v1.png`
| doorClosed     | Дверь закрыта | `https://cdn.example.com/props/door_closed_v1.png`
| doorOpen       | Дверь открыта | `https://cdn.example.com/props/door_open_v1.png`
| manifest       | Манифест ассетов | `https://cdn.example.com/manifest/tla-mvp-manifest.json`

## Протокол сообщений

**Клиент → Сервер**
- `hello` – вход в игру (имя необязательно).
- `move` – попытка шага по направлению (`N/S/E/W`). Сервер валидирует тайл.
- `openDoor` – переключение двери по `doorId` (только если игрок рядом).

**Сервер → Клиент**
- `welcome` – id игрока, снимок карты (50×50, 1 уровень, одна дверь) и текущее состояние.
- `state` – периодические обновления позиций игроков и состояний дверей (10 Гц, коалесцируются).
- `error` – текстовые ошибки (`tile blocked`, `unknown door` и т.д.).

### Диаграмма последовательностей (текст)

```
Client               Server
  | --- WS connect --> |
  | <--- accept ------- |
  | --- hello --------> |
  | <--- welcome ------ |
  |                    |
  | --- move/openDoor ->| (валидируется, при успехе меняется состояние)
  | <--- state -------- |
  | ...                |
```

## Игровая логика

- Сервер хранит полный снимок мира (позиции игроков, состояния дверей) и рассылает `state` не чаще 10 раз/с.
- Передвижение разрешено только по проходимым тайлам: карта целиком проходима, кроме клетки двери, если она закрыта.
- Дверь переключается атомарно, все клиенты получают обновление в одном `state`.
- Текущая карта: 50×50 плиток, тайл 48 px, дверь `d1` на координатах (12,12, уровень 0).

## Деплой на Render

- Один Docker-контейнер, который запускает `node dist/index.js` из `server/` (предварительно `npm run build`).
- Экспортируйте `PORT` (Render задаёт автоматически) — сервер его подхватит.
- Логи содержат события коннекта/дисконнекта и количество активных соединений.

## Смоук-тест

Минимальная проверка: после `npm run build && npm run dev` открыть две вкладки `http://localhost:3000`, убедиться, что перемещение стрелками отображается в обеих вкладках и дверь переключается кликом.

